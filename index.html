<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Falling Blocks DX — Tetris HTML5 (AR)</title>
  <meta name="theme-color" content="#0b1023">
  <style>
    :root{
      --bg1:#0b1023; --bg2:#16224a; --panel:#0f1530;
      --glass: rgba(255,255,255,.06); --line: rgba(255,255,255,.10);
      --text:#eef2f8; --muted:#a8b2c4; --accent:#22d3ee; --accent2:#a78bfa;
      --good:#34d399; --bad:#ef4444;
      --r:18px; --shadow:0 18px 48px rgba(0,0,0,.42);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1400px 1000px at 85% -10%, #24407d 0%, transparent 60%),
        radial-gradient(1200px 900px at 10% 110%, #1c345f 0%, transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      display:flex; align-items:center; justify-content:center; padding:14px; overflow:hidden;
    }
    .wrap{ width:min(1080px,100%); display:grid; grid-template-columns: 1fr 260px; gap:16px }
    @media (max-width: 920px){ .wrap{ grid-template-columns: 1fr } }
    .card{ background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line); border-radius:var(--r); box-shadow:var(--shadow) }
    header.card{ padding:14px 16px; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap }
    header h1{ margin:0; font-size: clamp(18px, 2.4vw, 26px); letter-spacing:.4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
    header .btns{ display:flex; gap:8px; flex-wrap:wrap }
    button{
      background:linear-gradient(180deg, #1b2b57, #0f172a);
      color:var(--text); border:1px solid var(--line);
      border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer;
      transition:.18s transform, .2s filter
    }
    button:hover{ transform:translateY(-1px); filter:brightness(1.08) }
    #game.card{ display:grid; grid-template-columns: 1fr 220px; gap:12px; padding:12px }
    @media (max-width: 920px){ #game.card{ grid-template-columns: 1fr } }
    .stage{ position:relative; display:grid; place-items:center }
    canvas#cv{ width:100%; max-width:560px; aspect-ratio: 10/20;
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border-radius:16px; box-shadow: inset 0 0 0 2px rgba(255,255,255,.06) }
    .side{ display:grid; grid-auto-rows: min-content; gap:12px }
    .panel{ background:var(--glass); border:1px solid var(--line); border-radius:14px; padding:10px }
    .panel h3{ margin:0 0 8px; font-size:14px; color:var(--muted) }
    canvas#next{ width:100%; aspect-ratio: 1/1; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)); border-radius:12px }
    .hud{ display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; margin:6px 0 10px }
    .stat{ background:var(--glass); border:1px solid var(--line); border-radius:12px; padding:8px 10px; text-align:center }
    .stat .k{ font-size:12px; color:var(--muted) } .stat .v{ font-size:20px; font-weight:800 }
    .controls{ display:flex; align-items:center; justify-content:center; gap:10px; margin-top:8px; flex-wrap:wrap }
    .controls button{ min-width:92px; font-size:16px; padding:12px 16px }
    .tip{ text-align:center; color:var(--muted); font-size:12px; margin-top:6px }
    .modal{ position:fixed; inset:0; display:none; place-items:center; background:rgba(10,14,26,.55); padding:18px; z-index:20 }
    .modal .box{ width:min(560px,100%); background:var(--panel); border:1px solid var(--line); border-radius:20px; padding:18px; box-shadow:var(--shadow) }
    .modal h2{ margin:0 0 6px; font-size:24px } .modal p{ margin:6px 0 14px; color:var(--muted) }
    .splash{ position:absolute; inset:0; display:grid; place-items:center; }
    .splash .inner{ background:var(--panel); border:1px solid var(--line); border-radius:18px; padding:16px; box-shadow:var(--shadow); text-align:center }
    .splash h2{ margin:0 0 10px }
    .legal{ color:var(--muted); font-size:12px; text-align:center; margin-top:8px }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>Falling Blocks DX — تترس (نسخة نظيفة)</h1>
      <div class="btns">
        <button id="newBtn">لعبة جديدة</button>
        <button id="pauseBtn">⏸︎ إيقاف</button>
        <button id="muteBtn">🔊 الصوت</button>
        <button id="howBtn">طريقة اللعب</button>
      </div>
    </header>

    <section id="game" class="card">
      <div class="hud">
        <div class="stat"><div class="k">النتيجة</div><div id="score" class="v">0</div></div>
        <div class="stat"><div class="k">الخطوط</div><div id="lines" class="v">0</div></div>
        <div class="stat"><div class="k">المستوى</div><div id="level" class="v">1</div></div>
        <div class="stat"><div class="k">أفضل نتيجة</div><div id="best" class="v">0</div></div>
      </div>

      <div class="stage">
        <canvas id="cv" width="320" height="640" aria-label="ساحة اللعب" role="img"></canvas>
        <div id="splash" class="splash">
          <div class="inner">
            <h2>ابدأ اللعب</h2>
            <p>↑ تدوير • ← → تحريك • ↓ إسقاط سريع • مسافة = هارد دروب</p>
            <button id="startBtn">ابدأ الآن</button>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="panel">
          <h3>القادم</h3>
          <canvas id="next" width="200" height="200"></canvas>
        </div>
        <div class="panel">
          <h3>التحكم</h3>
          <div class="controls">
            <button id="leftBtn">⟵ يسار</button>
            <button id="rotBtn">⤿ تدوير</button>
            <button id="rightBtn">يمين ⟶</button>
            <button id="downBtn">⬇ إسقاط</button>
            <button id="hardBtn">⬇⬇ هارد دروب</button>
          </div>
        </div>
        <div class="panel"><h3>تلميح</h3>
          <div class="tip">مسح صف كامل يضيف نقاط. السرعة تزيد كل 10 صفوف. نافذة “القادم” تعرض قطعة واحدة فقط.</div>
        </div>
      </div>

      <div class="legal">كود أصلي بالكامل — لا يستخدم أي أصول/أكواد من ألعاب أخرى. يعمل على الموبايل والكمبيوتر.</div>
    </section>
  </div>

  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="box">
      <h2 id="modalTitle">نهاية اللعبة</h2>
      <p id="modalMsg">امتلأت اللوحة من الأعلى.</p>
      <div style="display:flex; gap:10px; flex-wrap:wrap">
        <button id="againBtn">أعد المحاولة</button>
        <button id="shareBtn">مشاركة النتيجة</button>
      </div>
    </div>
  </div>

  <script>
  (()=>{
    // ===== Constants =====
    const COLS=10, ROWS=20;
    const cv = document.getElementById('cv');
    const cx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    const CS = Math.floor(W / COLS); // 32px on 320

    const nextCV = document.getElementById('next');
    const nx = nextCV.getContext('2d');

    // HUD
    const scoreEl = document.getElementById('score');
    const linesEl = document.getElementById('lines');
    const levelEl = document.getElementById('level');
    const bestEl  = document.getElementById('best');

    // Modal + splash
    const modal = document.getElementById('modal');
    const modalTitle = document.getElementById('modalTitle');
    const modalMsg = document.getElementById('modalMsg');
    const splash = document.getElementById('splash');

    // Audio
    let muted=false;
    function beep(freq=520, dur=60, gain=.08){
      if(muted) return;
      const a = new (window.AudioContext||window.webkitAudioContext)();
      const o=a.createOscillator(); const g=a.createGain();
      o.type='sine'; o.frequency.value=freq; o.connect(g); g.connect(a.destination);
      g.gain.setValueAtTime(gain,a.currentTime);
      g.gain.exponentialRampToValueAtTime(.0001,a.currentTime+dur/1000);
      o.start(); o.stop(a.currentTime+dur/1000);
      setTimeout(()=>a.close(), dur+120);
    }

    const COLORS = { I:'#22d3ee', O:'#f59e0b', T:'#a78bfa', S:'#34d399', Z:'#f87171', J:'#60a5fa', L:'#f472b6' };
    const SHAPES = {
      I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      O: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      T: [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      S: [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
      Z: [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      J: [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      L: [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]]
    };

    // Game state
    let grid, cur, bag=[], nextPiece=null, score=0, lines=0, level=1, best=Number(localStorage.getItem('tetris_best')||0);
    let dropInterval = 900; // ms — faster with level
    let dropTimer = 0, lastTime = 0, paused=false, running=false;

    function emptyGrid(){ return Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
    function newPiece(type){ const shape = JSON.parse(JSON.stringify(SHAPES[type])); return { type, shape, x: Math.floor(COLS/2)-2, y: -2, color: COLORS[type] }; }
    function takeFromBag(){ if(bag.length===0){ bag = Object.keys(SHAPES).sort(()=>Math.random()-.5); } return bag.pop(); }
    function spawn(){ const t = nextPiece || takeFromBag(); cur = newPiece(t); nextPiece = takeFromBag(); drawNext(); if(collide(cur, cur.x, cur.y)) gameOver('امتلأت اللوحة من الأعلى.'); }

    function rotateCW(shape){ const N = shape.length; const res = Array.from({length:N}, ()=>Array(N).fill(0)); for(let y=0;y<N;y++) for(let x=0;x<N;x++) res[x][N-1-y]=shape[y][x]; return res; }
    function tryRotate(){ const rotated = rotateCW(cur.shape); const kicks=[0,-1,1,-2,2]; for(const dx of kicks){ if(!collide(cur, cur.x+dx, cur.y, rotated)){ cur.shape=rotated; cur.x+=dx; beep(720,60,.06); return; } } }

    function collide(piece, nx, ny, shape=piece.shape){
      for(let y=0;y<4;y++) for(let x=0;x<4;x++){
        if(!shape[y][x]) continue;
        const gx = nx + x, gy = ny + y;
        if(gy < 0) continue;
        if(gx<0 || gx>=COLS || gy>=ROWS) return true;
        if(grid[gy][gx]) return true;
      }
      return false;
    }

    function merge(piece){ for(let y=0;y<4;y++) for(let x=0;x<4;x++){ if(!piece.shape[y][x]) continue; const gx = piece.x + x, gy = piece.y + y; if(gy>=0) grid[gy][gx] = piece.color; } }
    function clearLines(){
      let cleared=0;
      for(let y=ROWS-1; y>=0;){ if(grid[y].every(v=>v)){ grid.splice(y,1); grid.unshift(Array(COLS).fill(0)); cleared++; } else y--; }
      if(cleared){ const table={1:100,2:300,3:500,4:800}; score += table[cleared] || (cleared*300); lines += cleared; level = 1 + Math.floor(lines/10); dropInterval = Math.max(120, 900 - (level-1)*70); beep(600,80,.09); }
    }

    function draw(){
      cx.clearRect(0,0,W,H);
      // soft bg
      const grd = cx.createLinearGradient(0,0,0,H);
      grd.addColorStop(0,'rgba(255,255,255,.06)'); grd.addColorStop(1,'rgba(255,255,255,.02)');
      cx.fillStyle = grd; cx.fillRect(0,0,W,H);
      // grid
      cx.strokeStyle = 'rgba(255,255,255,.08)'; cx.lineWidth = 1;
      for(let x=0;x<=COLS;x++){ cx.beginPath(); cx.moveTo(x*CS+.5,0); cx.lineTo(x*CS+.5,H); cx.stroke(); }
      for(let y=0;y<=ROWS;y++){ cx.beginPath(); cx.moveTo(0,y*CS+.5); cx.lineTo(W,y*CS+.5); cx.stroke(); }
      // fixed cells
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(grid[y][x]) drawCell(x,y,grid[y][x]);
      // current piece
      for(let y=0;y<4;y++) for(let x=0;x<4;x++) if(cur.shape[y][x]) drawCell(cur.x+x, cur.y+y, cur.color, true);
    }

    function drawCell(gx,gy,color,floating=false){
      if(gy<0) return;
      const px=gx*CS, py=gy*CS, r=6;
      cx.save(); cx.shadowColor='rgba(0,0,0,.35)'; cx.shadowBlur=10; cx.shadowOffsetY=6;
      const grad = cx.createLinearGradient(px,py,px,py+CS);
      grad.addColorStop(0, shade(color,1.15)); grad.addColorStop(1, shade(color,0.88));
      roundRect(cx, px+2, py+2, CS-4, CS-4, r, true, false, grad);
      cx.restore();
      cx.fillStyle='rgba(255,255,255,.14)'; roundRect(cx, px+6, py+5, CS-12, 6, 4, true);
      cx.strokeStyle='rgba(255,255,255,.12)'; cx.lineWidth=1; roundRect(cx, px+2, py+2, CS-4, CS-4, r, false, true);
      if(floating){ cx.globalAlpha=.12; cx.fillStyle=color; cx.fillRect(px+4, py+CS-6, CS-8, 3); cx.globalAlpha=1; }
    }
    function shade(hex,k){ const f=parseInt(hex.slice(1),16),t=k<1?0:255,p=k<1?k:k-1; const R=f>>16,G=f>>8&255,B=f&255; const nr=Math.round((t-R)*p+R),ng=Math.round((t-G)*p+G),nb=Math.round((t-B)*p+B); return `rgb(${nr},${ng},${nb})`; }
    function roundRect(ctx,x,y,w,h,r,fill=false,stroke=false,fillStyle){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill){ ctx.fillStyle=fillStyle||'rgba(255,255,255,.08)'; ctx.fill(); } if(stroke){ ctx.stroke(); } }

    function drawNext(){
      nx.clearRect(0,0,nextCV.width,nextCV.height);
      const shape = SHAPES[nextPiece]; const col = COLORS[nextPiece];
      let minX=4,maxX=-1,minY=4,maxY=-1;
      for(let yy=0;yy<4;yy++) for(let xx=0;xx<4;xx++) if(shape[yy][xx]){ minX=Math.min(minX,xx); maxX=Math.max(maxX,xx); minY=Math.min(minY,yy); maxY=Math.max(maxY,yy); }
      const cellsX=maxX-minX+1, cellsY=maxY-minY+1;
      const s = Math.floor(Math.min((nextCV.width-40)/cellsX, (nextCV.height-40)/cellsY));
      const startX = Math.floor((nextCV.width - s*cellsX)/2);
      const startY = Math.floor((nextCV.height - s*cellsY)/2);
      for(let yy=minY; yy<=maxY; yy++) for(let xx=minX; xx<=maxX; xx++) if(shape[yy][xx]) drawPreview(startX + (xx-minX)*s, startY + (yy-minY)*s, s, col);
    }
    function drawPreview(px,py,s,color){
      const r=6; const grad=nx.createLinearGradient(px,py,px,py+s);
      grad.addColorStop(0, shade(color,1.15)); grad.addColorStop(1, shade(color,0.88));
      nx.shadowColor='rgba(0,0,0,.25)'; nx.shadowBlur=8; nx.shadowOffsetY=4;
      roundRect(nx, px+2, py+2, s-4, s-4, r, true, false, grad);
      nx.shadowBlur=0; nx.shadowOffsetY=0; nx.strokeStyle='rgba(255,255,255,.12)'; nx.lineWidth=1; roundRect(nx, px+2, py+2, s-4, s-4, r, false, true);
    }

    // Update loop
    function update(dt){ if(paused || !running) return; dropTimer += dt; if(dropTimer > dropInterval){ dropTimer = 0; if(!move(0,1)){ lock(); } } }
    function move(dx,dy){ if(!collide(cur, cur.x+dx, cur.y+dy)){ cur.x += dx; cur.y += dy; return true; } return false; }
    function hardDrop(){ let d=0; while(move(0,1)) d++; score += Math.min(2*d, 40); lock(); }
    function lock(){ merge(cur); clearLines(); spawn(); updateHUD(); draw(); beep(520,60,.06); }
    function updateHUD(){ scoreEl.textContent = score; linesEl.textContent = lines; levelEl.textContent = level; bestEl.textContent = Math.max(best, score); }

    function gameOver(reason){ running=false; paused=false; best=Math.max(best,score); localStorage.setItem('tetris_best', best); updateHUD(); showModal('نهاية اللعبة', `${reason} نتيجتك: ${score}`); beep(240,140,.08); }
    function showModal(title,msg){ modalTitle.textContent=title; modalMsg.textContent=msg; modal.style.display='grid'; }
    function hideModal(){ modal.style.display='none'; }

    // Inputs
    window.addEventListener('keydown',(e)=>{
      if(splash.style.display!=='none'){ if(e.key===' '||e.key==='Enter'){ startGame(); } return; }
      if(!running) return;
      if(e.key==='ArrowLeft'||e.key==='a'){ move(-1,0); draw(); }
      if(e.key==='ArrowRight'||e.key==='d'){ move(1,0); draw(); }
      if(e.key==='ArrowDown'||e.key==='s'){ if(move(0,1)){ score+=1; updateHUD(); draw(); } }
      if(e.key==='ArrowUp'||e.key==='w'){ tryRotate(); draw(); }
      if(e.code==='Space'){ e.preventDefault(); hardDrop(); draw(); }
      if(e.key.toLowerCase()==='p'){ togglePause(); }
    });

    // Touch buttons
    const id = s => document.getElementById(s);
    id('leftBtn').onpointerdown = ()=>{ if(running){ move(-1,0); draw(); } };
    id('rightBtn').onpointerdown= ()=>{ if(running){ move(1,0); draw(); } };
    id('downBtn').onpointerdown = ()=>{ if(running){ if(move(0,1)){ score+=1; updateHUD(); draw(); } } };
    id('rotBtn').onpointerdown  = ()=>{ if(running){ tryRotate(); draw(); } };
    id('hardBtn').onpointerdown = ()=>{ if(running){ hardDrop(); draw(); } };

    // Top buttons
    id('newBtn').addEventListener('click', startGame);
    id('againBtn')?.addEventListener('click', startGame);
    id('shareBtn')?.addEventListener('click', ()=>{
      const text = `🎮 سجلت ${score} نقطة في Falling Blocks DX!`;
      navigator.clipboard && navigator.clipboard.writeText(text);
      modalMsg.textContent='تم نسخ نتيجتك — الصقها أينما تريد!';
    });
    id('howBtn').addEventListener('click', ()=>{ showModal('طريقة اللعب','قطعة رباعية تسقط من الأعلى تلقائيًا. حرّكها بالأسهم أو الأزرار. ↑ للتدوير، ↓ لإسقاط سريع، مسافة = هارد دروب. عند اكتمال صفّ يمسح ويزيد رصيدك، وتزيد السرعة كل 10 صفوف.'); });
    id('muteBtn').addEventListener('click', (e)=>{ muted=!muted; e.target.textContent = muted? '🔇 صامت':'🔊 الصوت'; });
    id('pauseBtn').addEventListener('click', ()=> togglePause());
    id('startBtn').addEventListener('click', startGame);

    function togglePause(){
      if(!running) return;
      paused = !paused;
      document.getElementById('pauseBtn').textContent = paused? '▶︎ متابعة':'⏸︎ إيقاف';
    }

    function startGame(){
      hideModal();
      splash.style.display='none';
      grid = emptyGrid(); score=0; lines=0; level=1; dropInterval=900; dropTimer=0; paused=false; running=true; bag=[]; nextPiece=null;
      spawn(); updateHUD(); draw(); lastTime = performance.now(); requestAnimationFrame(tick);
    }

    function tick(now){ if(!running){ draw(); return; } const dt = now-lastTime; lastTime=now; if(!paused){ update(dt); draw(); } requestAnimationFrame(tick); }

    // Responsive scale
    const ro = new ResizeObserver(()=>{
      const el = cv; const p = el.parentElement; const size = Math.min(560, p.clientWidth);
      el.style.width = size+'px'; el.style.height = (size*2)+'px';
    });
    ro.observe(cv.parentElement);
  })();
  </script>
</body>
</html>
